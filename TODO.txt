
- We could use some sort of builds/index.db in order to find existing builds.

  SQLite schema:

    migrations: lift this from my web projects

    builds:
        
        - id
        - cache_path
        - build_path
        - created_at
        - user_specification (normalized via Package.__str__)
        - manager (without options)
        - package (without options)

        Below can be provided by the user, but also discovered at build time.
        package.setattr('version', version, specificity=4) # stores the highest specificity
            _version_specificity stores the current specificity

        - name (defaults to $package)
        - version
        - revision
        - commit (do we need this, or can we overload revision?)

- something to report on what is already linked into and environment:
    - $environment/etc/vee.txt
    - $environment/etc/vee.db
    - $environment/etc/vee/linked/$package_name.txt


- custom managers

    - PyAV has special build instructions

    `vee install PyAV.py`, where PyAV.py contains:

        - REQUIREMENT = 'https://pypi.python.org/packages/source/a/av/av-0.2.2.tar.gz#md5=ec0198f28d9294d20b54b0ac3a9ff77d'
        - DEPENDS_ON = ['lib:ffmpeg']
        - MANAGER or PyAVManager or PyavManager, which inherits from BaseManager


- pip manager
    - for now, we can just link to the archives
    - can we vendor pip?
        see: https://bootstrap.pypa.io/get-pip.py


- `vee clone` for dev?

- match how Homebrew links directories

- Homebrew is only installing the tree of the one package, not any of the
  dependencies. It should also link the dependencies. Perhaps there should be
  a Requirements.dependencies() which returns them all, and then makes
  sure they are all linked.

  Another solution to this problem is to have paths_to_install() return a list.

  Another solution is for HomebrewManager.install() to do this itself

  An AbstractRequirement is one like "lib:ffmpeg", "py:yaml", etc., that just
  know what result they want, but not where it is from. A DependencyInterface
  could be the intersection of AbstractRequirement and Requirement, such that

  Requirement.dependencies() can return real ones (e.g. from `brew deps`)
  and abstract ones. It is permitted to return different dependencies on each
  call (as they are discovered, e.g.)

  DependencyResolver can take a pool of requirements and figure out what order
  they should be installed in (via C3)

        .add(requirement)
        .rescan_dependencies()
        .linearize()


- Packages need to identify what they provide, so that others can depend on them.
    
    homebrew+ffmpeg provides "lib:ffmpeg" and "bin:ffmpeg". PyAV needs "lib:ffmpeg":

    PKG_CONFIG_PATH = home.absbuild('lib:ffmpeg', 'lib', 'pkg-config')


- homebrew taps: homebrew+mikeboers/testbrew/foo
    - we would need a way to detect which tap it is
    - we can grep `brew info $forumla` for From: https://github.com/#{user}/#{repo}/blob/master/#{path}


- commands

    vee init REPO
    vee update
    vee upgrade

    √ vee install REQUIREMENT
    - vee install -r requirements.txt
    √ vee link NAME REQUIREMENTS_FILE




